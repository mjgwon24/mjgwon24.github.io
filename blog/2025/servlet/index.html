<!DOCTYPE html>
<html lang="en">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <title> Servlet | mjgwon24 </title>
  <meta name="author" content="mjgwon24">
  <meta name="description" content="mjgwon24's blog">
  <meta name="keywords" content="mjgwon24, blog, Servlet, developer, 개발자, JavaEE">
  <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04">
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css"
        integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous">
  <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5">
  <link defer rel="stylesheet" href="/assets/css/scholar-icons.css?62b2ac103a88034e6882a5be5f3e2772">
  <link defer rel="stylesheet" type="text/css"
        href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap">
  <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99"
        media="" id="highlight_theme_light">
  <!--  <link rel="shortcut icon"-->
  <!--        href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;">-->
  <link rel="shortcut icon" href="/assets/logo.ico/favicon.ico" />
  <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e">
  <link rel="canonical" href="https://mjgwon24.github.io/blog/2025/howToUseCTE/">
  <script src="/assets/js/theme.js?9a0c749ec5240d9cda97bc72359a72c0"></script>
  <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca"
        media="none" id="highlight_theme_dark">
  <script>
    initTheme();
  </script>
</head>
<body class="fixed-top-nav ">
<header>
  <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation">
    <div class="container"><a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">mjgwon24</span>
    </a>
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav"
              aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"><span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span
          class="icon-bar bottom-bar"></span></button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <li class="nav-item "><a class="nav-link" href="/">about </a></li>
          <li class="nav-item active"><a class="nav-link" href="/blog/">blog </a></li>
          <li class="nav-item">
            <button id="search-toggle" title="Search" onclick="openSearchModal()"><span class="nav-link">ctrl k <i
              class="ti ti-search"></i></span></button>
          </li>
          <li class="toggle-container">
            <button id="light-toggle" title="Change theme"><i class="ti ti-sun-moon" id="light-toggle-system"></i> <i
              class="ti ti-moon-filled" id="light-toggle-dark"></i> <i class="ti ti-sun-filled"
                                                                       id="light-toggle-light"></i></button>
          </li>
        </ul>
      </div>
    </div>
  </nav>
  <progress id="progress" value="0">
    <div class="progress-container"><span class="progress-bar"></span></div>
  </progress>
</header>
<div class="container mt-5" role="main">
  <div class="row">
    <div class="col-sm-3">
      <nav id="toc-sidebar" class="sticky-top"></nav>
    </div>
    <div class="col-sm-9">
      <div class="post">
        <header class="post-header"><h1 class="post-title font-weight-normal">Servlet 탐구</h1>
          <p class="post-meta"> Created in Febrary 25, 2025 </p>
          <p class="post-tags"><a href="/blog/2025"> <i class="fa-solid fa-calendar fa-sm"></i> 2025 </a>   ·   <a
            href="/blog/tag/javaEE"> <i class="fa-solid fa-hashtag fa-sm"></i> javaEE</a></p></header>
        <article class="post-content">
          <div id="markdown-content">

            <br/>

            <p class="font-weight-normal">
              다양한 서비스들에서 Servlet 기반 코드가 많이 사용되고는 합니다.
              <br />
              처음에는 Servlet은 단순히 요청을 받고 응답을 돌려주는 역할이라고 생각하며 깊게 공부하지 않았는데, 최근 디버깅을 하다 보니 그 내부에서 일어나는 일들이 생각보다 복잡하다는것을 알게되었습니다.
              <br />
              <br />
              그래서 이번 포스팅을 통해 Servlet이 어떻게 동작하는지, 그리고 어떻게 사용하는지에 대해 알아보고, 조사한 점과 새롭게 알게된 점들을 풀어보려 합니다.
            </p>

            <br/>
            <br/>

            <h2 id="sub-heading-1" class="font-weight-normal">Servlet은 왜 생겨난 것인가?</h2>

            <p class="font-weight-normal">
              Servlet이 등장하기 전의 시간으로 돌아가봅시다.
              당시에는 HTML로 구성된 정적인 웹 페이지만을 제공할 수 있었습니다.
              정적인 웹 페이지는 사용자와 상호작용이 불가능하며, 사용자의 요청에 따라 동적인 웹 페이지를 제공할 수 없었습니다.
              이러한 문제를 해결하기 위해, 동적 웹 페이지를 생성하기 위한 CGI(Common Gateway Interface)가 등장하게 되었습니다.

              <br/>
              <br/>

              Perl이나 C로 작성된 CGI는 웹 서버에서 요청을 받으면 새로운 프로세스를 생성하여 요청을 처리하고 응답을 돌려주는 방식으로 동작합니다.
              이러한 방식은 매 요청마다 프로세스를 생성하고 종료하기 때문에 매우 느리다는 단점이 있었습니다.
              서버 부하도 컸고, 성능 또한 좋지 않았습니다.
              <br />
              <br />
              이에 더해 당시 웹은 기본적으로 stateless(상태를 유지하지 않음)한 특성을 가지고 있었기 때문에, 사용자의 상태를 유지하기 위해 별도의 방법이 필요했습니다.
              예를 들어, 사용자의 로그인 상태를 유지하기 위해 <code class="language-plaintext highlighter-rouge">query string</code>이나 <code class="language-plaintext highlighter-rouge">
              hidden form field</code>를 사용하는 등 보안이 취약한 방법을 사용해야 했습니다.

              <br/>
              <br/>

              이러한 단점을 보완하기 위해 Java 플랫폼의 일부로 Servlet이 등장하게 되었습니다.
            </p>

            <br/>
            <br/>

            <h2 id="sub-heading-2" class="font-weight-normal">Servlet의 탄생</h2>

            <p class="font-weight-normal">
              Servlet은 Java EE(Java Platform, Enterprise Edition) 환경에서 동작하는 서버 사이드 프로그래밍 기술입니다.
              HTTP 요청을 처리하고 동적인 웹 페이지를 생성하는 역할을 수행합니다.

              <br/>
              <br/>

              <span class="font-weight-bold">컨테이너의 등장</span>
              <br />
              Servlet은 Tomcat, Jetty 같은 서블릿 컨테이너에서 동작합니다.
              컨테이너가 요청 라우팅, 생명주기 관리, 스레드 풀 등 인프라를 맡아 처리하므로, 개발자는 비즈니스 로직에만 집중할 수 있습니다.
              <br />
              <span class="font-weight-lighter font-italic" style="font-size: 14px">* 요청 라우팅: URL 매핑을 통해 요청을 처리할 서블릿을 찾아주는 역할</span>
              <br />
              <span class="font-weight-lighter font-italic" style="font-size: 14px">* 생명주기 관리: 서블릿의 생명주기를 관리하고, 초기화, 서비스, 소멸 단계를 처리</span>
              <br />
              <span class="font-weight-lighter font-italic" style="font-size: 14px">* 스레드 풀: 요청마다 스레드를 생성하는 것이 아니라, 미리 생성된 스레드 풀에서 스레드를 할당해 처리</span>

              <br />
              <br />

              <span class="font-weight-bold">스레드 기반 처리</span>
              <br />
              Servlet은 CGI처럼 프로세스를 새로 띄우는 대신, Java의 멀티스레딩을 활용해 요청을 처리합니다.
              Servlet 인스턴스는 컨테이너에 의해 한 번 생성되고, 이후 요청마다 스레드가 할당돼 요청을 처리합니다.
              이를 통해 CGI보다 빠른 응답 속도를 제공할 수 있게 되었고, 서버 자원을 효율적으로 사용할 수 있게 되었습니다.

              <br/>
              <br/>

              <span class="font-weight-bold">Java 생태계와의 통합</span>
              <br />
              Servlet은 JDBC, JSP, EJB 등 다양한 Java EE 기술과 통합되어 사용될 수 있습니다.
              특히 엔터프라이즈 환경에서 복잡한 비즈니스 로직을 처리하기 위한 기반이 되는 기술입니다.
              상태 관리와 같은 기능도 <code class="language-plaintext highlighter-rouge">HttpSession</code>과 같은 Java EE 기술을 통해 쉽게 구현할 수 있습니다.

              <br/>
              <br/>

              Servlet은 단순히 기술적인 진보를 넘어, 웹 애플리케이션 개발의 패러다임을 바꿔놓은 기술이라고 할 수 있습니다.
            </p>

            <br/>
            <br/>

            <h2 id="sub-heading-3" class="font-weight-normal">Servlet의 생명주기</h2>

            <p class="font-weight-normal">
              Servlet은 단순한 Java 클래스처럼 보이지만, Tomcat이나 Jetty 같은 서블릿 컨테이너가 그 생명주기를 관리하면서 힘을 발휘합니다.
              Servlet의 생명주기는 서블릿 컨테이너(Servlet Container)에 의해 관리되며, 3가지 주요 단계로 이루어집니다.
              <br />
              <br />
            </p>

            <p class="font-weight-normal">
              <span class="font-weight-bold">1. 초기화(Initialization): init()</span>
              <br />
              Servlet이 처음 메모리에 올라갈 때 컨테이너가 <code class="language-plaintext highlighter-rouge">init()</code> 메서드를 호출합니다.
              여기서 설정을 읽거나 자원을 준비하는 작업을 수행합니다.
              데이터베이스 연결이나 외부 API 토큰을 초기화하는 작업을 주로 수행합니다.
            </p>

            <br />

            <p class="font-weight-normal">
              <span class="font-weight-bold">2. 서비스(Service): service()</span>
              <br />
              클라이언트의 요청이 들어올 때 마다 서블릿 컨테이너는 <code class="language-plaintext highlighter-rouge">service()</code> 메서드를 호출합니다.
              <code class="language-plaintext highlighter-rouge">service()</code> 메서드는 <code class="language-plaintext highlighter-rouge">HTTP</code> 메서드에 따라 <code class="language-plaintext highlighter-rouge">doGet()</code>, <code class="language-plaintext highlighter-rouge">doPost()</code>로 분기됩니다.
            </p>

            <br />

            <p class="font-weight-normal">
              <span class="font-weight-bold">3. 소멸(Destroy): destroy()</span>
              <br />
              Servlet이 컨테이너에서 내려갈 때 <code class="language-plaintext highlighter-rouge">destroy()</code> 메서드가 호출됩니다.
              열린 파일이나 DB 연결 같은 자원을 정리하는 작업을 수행합니다.
              만약 커넥션 풀을 닫지 않으면, 메모리 누수가 발생할 수 있습니다.
              <br />
              <br />

              이러한 생명주기를 통해 서블릿은 초기화 작업을 수행하고, 클라이언트의 요청을 처리한 뒤에는 자원을 정리하고 소멸됩니다.
            </p>

            <br/>
            <br/>

            <h2 id="sub-heading-4" class="font-weight-normal">Servlet 동작 원리</h2>

            <p class="font-weight-normal">
              Servlet은 클라이언트 요청을 받아 서버에서 처리한 뒤 응답을 돌려주는 Java 클래스입니다.
              하지만 그 과정은 단순히 메서드 호출 하나로 끝나지 않습니다.
              컨테이너와의 상호작용, 스레드 관리 등 여러 층위에서 동작합니다.

              <br />
              <br />

              <span class="font-weight-bold">1. 요청 수신과 컨테이너의 역할</span>
              <br />
              사용자가 브라우저에서 URL을 입력하면, 웹 서버(ex. Apache)가 요청을 받아 서블릿 컨테이너(ex. Tomcat)로 넘깁니다.
              컨테이너는 URL 매핑(<code class="language-plaintext highlighter-rouge">web.xml</code> 또는 <code class="language-plaintext highlighter-rouge">@WebServlet</code>)을 통해 요청을 처리할 서블릿을 찾습니다.

              <br />
              <br />

              <span class="font-weight-bold">2. 스레드 할당과 싱글톤 동작</span>
              <br />
              서블릿은 싱글톤으로 동작합니다. 즉, 하나의 인스턴스가 여러 요청을 처리합니다.
              이 싱글톤 구조 덕분에 메모리를 아낄 수 있지만, 상태 관리에 세심한 주의가 필요합니다.

              <br />
              <br />

              <span class="font-weight-bold">3. 요청 처리와 응답</span>
              <br />
              <code class="language-plaintext highlighter-rouge">doGet()</code>, <code class="language-plaintext highlighter-rouge">doPost()</code> 메서드를 통해 요청을 처리하고,
              <code class="language-plaintext highlighter-rouge">HttpServletResponse</code> 객체를 통해 HTML, JSON 같은 응답을 만들어 클라이언트로 보냅니다.
              <br />
              이때 출력 스트림(ex. <code class="language-plaintext highlighter-rouge">PrintWriter</code>, <code class="language-plaintext highlighter-rouge">OutputStream</code>) 을 다루는 게 중요한데, 스트림을 열었다가 닫지 않으면 메모리 누수가 발생할 수 있습니다.
              JVM의 가비지 컬렉터나 스트림 객체 자체를 회수하더라도, 스트림이 연결된 운영체제 수준의 리소스(파일 디스크립터 등)는 명시적으로 닫히지 않으면 계속 점유될 수 있기 때문입니다.
              <br />
              <span class="font-weight-lighter font-italic" style="font-size: 14px">
                * <code class="language-plaintext highlighter-rouge">try-with-resources</code>는 Java 7부터 지원되는 기능으로, <code class="language-plaintext highlighter-rouge">AutoCloseable</code> 또는 <code class="language-plaintext highlighter-rouge">Closeable</code> 인터페이스를 구현한 자원을 자동으로 닫아줍니다.
                <code class="language-plaintext highlighter-rouge">try-with-resources</code>로 <code class="language-plaintext highlighter-rouge">PrintWriter</code>를 감싸면 깔끔하게 자원을 닫을 수 있습니다.
              </span>
            </p>

            <br/>
            <br/>

            <h2 id="sub-heading-5" class="font-weight-normal">Servlet 사용 방법</h2>

            <p class="font-weight-normal">
              Servlet을 사용하기위해 자주 쓰이는 패턴을 알아보겠습니다.
              <br />
              <br />

              <span class="font-weight-bold">1. 기본 구현</span>
              <br />

              <code class="language-plaintext highlighter-rouge">HttpServlet</code>을 상속받아 <code class="language-plaintext highlighter-rouge">doGet()</code>, <code class="language-plaintext highlighter-rouge">doPost()</code> 메서드를 오버라이드합니다.
              예를 들어, 코드로 작성하면 아래와 같습니다.
            </p>

              <div class="language-java highlighter-rouge">
                <div class="highlight">
                  <pre class="highlight">
  <code data-lang="java">
    <span class="c1">/*</span>
    <span class="c1"> * 아래 WebServlet 설정 방식은 web.xml의 아래 설정과 동일함 </span>
    <span class="c1"> * &lt;servlet-name&gt; MyFirstServlet &lt;/servlet-name&gt;</span>
    <span class="c1"> * &lt;url-pattern&gt; /servlets/Firstservlet &lt;/url-pattern&gt;</span>
    <span class="c1"> */</span>
    <span class="s">@WebServlet</span><span class="p">(</span><span class="s">"/hello"</span><span class="p">)</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">FirstServlet</span> <span class="k">extends</span> <span class="nc">HttpServlet</span> <span class="p">{</span>
    <span class="c1">	</span><span class="s">@Override</span>
    <span class="k">    protected</span> <span class="kt">void</span> <span class="nf">doGet</span><span class="p">(</span><span class="nc">HttpServletRequest</span> <span class="n">req</span><span class="p">,</span> <span class="nc">HttpServletResponse</span> <span class="n">resp</span><span class="p">)</span> <span class="k">throws</span> <span class="nc">ServletException</span><span class="p">,</span> <span class="nc">IOException</span> <span class="p">{</span>
    <span class="c1">     </span><span class="nb">System</span><span class="p">.</span><span class="nb">out</span><span class="p">.</span><span class="nf">println</span><span class="p">(</span><span class="s">"Hello First Servlet!!"</span><span class="p">);</span>
    <span class="c1">	</span><span class="p">}</span>
    <span class="p">}</span></code>
                  </pre>
                </div>
          </div>

            <p class="font-weight-normal">
            <code class="language-plaintext highlighter-rouge">@WebServlet("/hello")</code> 어노테이션이나 <code class="language-plaintext highlighter-rouge">web.xml</code>에 서블릿 매핑을 추가합니다.

              <br />
              <br />

              <span class="font-weight-bold">2. 파라미터와 세션</span>
              <br />
              요청 파라미터는 <code class="language-plaintext highlighter-rouge">req.getParameter()</code>로, 세션은 <code class="language-plaintext highlighter-rouge">req.getSession()</code>으로 가져올 수 있습니다.
              주로 로그인 상태를 세션에 저장하거나, 쿼리 파라미터로 필터 조건을 받아 처리할 때 사용합니다.
              <br />
              이때, 파라미터 검증을 하지 않으면 null 포인터 익셉션이 발생할 수 있습니다.
              보통 <code class="language-plaintext highlighter-rouge">StringUtils.isEmpty()</code> 같은 유틸리티 메서드를 사용해 방어 코드를 작성합니다.
            </p>

            <br />
            <br />

            <h2 id="sub-heading-6" class="font-weight-normal">Servlet과 필터</h2>

            <p class="font-weight-normal">
              필터(Filter)는 Servlet의 앞뒤로 로직을 끼워 넣어 요청과 응답을 가로채는 역할을 합니다.
              필터와 Servlet을 조합한 몇가지 패턴을 알아보도록 하겠습니다.
              <br />
              <br />

              <span class="font-weight-bold">1. 인증/인가 처리</span><br />

              로그인 여부를 확인하는 필터를 만들어 모든 요청에 대해 로그인 여부를 확인하고, 로그인이 되어 있지 않다면 로그인 페이지로 리다이렉트하는 방식입니다.
              세션이 만료된 요청을 걸러내거나, 특정 URL에 대해 권한을 확인하는 용도로 사용됩니다.
              코드 예시는 아래와 같습니다.
            </p>

            <div class="language-java highlighter-rouge">
              <div class="highlight">
                <pre class="highlight">
  <code data-lang="java">
    <span class="s">@WebFilter</span><span class="p">(</span><span class="s">"/secure/*"</span><span class="p">)</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">AuthFilter</span> <span class="k">implements</span> <span class="nc">Filter</span> <span class="p">{</span>
        <span class="s">@Override</span>
        <span class="k">public</span> <span class="kt">void</span> <span class="nf">doFilter</span><span class="p">(</span><span class="nc">ServletRequest</span> <span class="n">request</span>, <span class="nc">ServletResponse</span> <span class="n">response</span>, <span class="nc">FilterChain</span> <span class="n">chain</span><span class="p">)</span>
        <span class="k">throws</span> <span class="nc">IOException</span>, <span class="nc">ServletException</span> <span class="p">{</span>
            <span class="nc">HttpServletRequest</span> <span class="n">req</span> = (<span class="nc">HttpServletRequest</span>) <span class="n">request</span>;
            <span class="nc">HttpServletResponse</span> <span class="n">resp</span> = (<span class="nc">HttpServletResponse</span>) <span class="n">response</span>;

            <span class="c1">// 로그인 여부 확인</span>
            <span class="k">if</span> (<span class="n">req</span>.<span class="nf">getSession</span>().<span class="nf">getAttribute</span>(<span class="s">"user"</span>) == <span class="kc">null</span>) {
                <span class="c1">// 로그인 페이지로 리다이렉트</span>
                <span class="n">resp</span>.<span class="nf">sendRedirect</span>(<span class="s">"/login.jsp"</span>);
                <span class="k">return</span>;
            }
            <span class="c1">// 필터 체인 계속 진행</span>
            <span class="n">chain</span>.<span class="nf">doFilter</span>(<span class="n">request</span>, <span class="n">response</span>);
        <span class="p">}</span>
    <span class="p">}</span></code>
                </pre>
              </div>
            </div>

            필터는 로그인된 사용자인지 확인한 후, 비로그인 상태라면 로그인 페이지로 리다이렉트합니다.
            로그인된 사용자라면, 요청을 계속 진행하도록 <code class="language-plaintext highlighter-rouge">chain.doFilter()</code>를 호출합니다.
            <br />
            <br />
            <span class="font-weight-bold">2. 로깅 처리 및 모니터링</span><br />
            요청 처리 시간을 측정하는 필터를 붙여 성능을 모니터링할 수 있습니다.
            시작 시간과 끝 시간을 기록하여 처리 시간을 측정하거나, 요청 정보를 로깅하는 용도로 사용됩니다.
            <code class="language-plaintext highlighter-rouge">req.getRequestURI()</code>와 <code class="language-plaintext highlighter-rouge">System.currentTimeMillis()</code>를 사용하여 요청 URL과 시간을 기록할 수 있습니다.

            <br />
            <br />
            <span class="font-weight-bold">3. 인코딩 설정</span><br />
            POST 요청에서 한글 깨짐을 막기위해 UTF-8 인코딩을 설정하는 필터를 만들어 사용할 수 있습니다.
            <code class="language-plaintext highlighter-rouge">req.setCharacterEncoding("UTF-8")</code>을 호출하면 요청의 인코딩을 변경할 수 있습니다.


            <br />
            <br />
            <br />

            <h2 id="sub-heading-7" class="font-weight-normal">Servlet과 EJB</h2>

            <p class="font-weight-normal">
              Servlet이 요청 처리의 최전선이라면, EJB(Enterprise JavaBeans)는 비즈니스 로직을 처리하는 중심입니다.
              EJB는 비즈니스 로직을 캡슐화하고 분산 환경을 다루는 데 강점을 가지고 있습니다.
              특히 금융권이나 레거시 엔터프라이즈 시스템에서 두 기술의 조합을 많이 사용합니다.
              아래에서 이 두 기술이 어떻게 연계되는지 알아보겠습니다.

              <br />
              <br />

              <span class="font-weight-bold">1. 서블릿에서 EJB 호출</span><br />

              Servlet은 HTTP 요청을 받아 EJB의 <code class="language-plaintext highlighter-rouge">Session Bean</code>을 호출해 복잡한 로직을 처리합니다.
              <br />
              <br />
              예를 들어, 주문 시스템에서 서블릿이 주문 요청을 받고 EJB가 결제 트랜잭션을 관리할 수 있습니다.
              JNDI(Java Naming and Directory Interface)를 통해 EJB를 lookup할 수 있습니다.
              <br />
              <br />
              그러나 lookup은 비용이 많이 들기 때문에, <code class="language-plaintext highlighter-rouge">@EJB</code> 어노테이션이나 프록시 캐싱을 사용해 재사용성을 높여주는 방법도 사용할 수 있습니다.
            </p>

            <div class="language-java highlighter-rouge">
              <div class="highlight">
                <pre class="highlight">
  <code data-lang="java">
    <span class="s">@WebServlet</span><span class="p">(</span><span class="s">"/order"</span><span class="p">)</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">OrderServlet</span> <span class="k">extends</span> <span class="nc">HttpServlet</span> <span class="p">{</span>
        <span class="s">@EJB</span>
        <span class="k">private</span> <span class="nc">OrderService</span> <span class="n">orderService</span><span class="p">;</span>

        <span class="s">@Override</span>
        <span class="k">protected</span> <span class="kt">void</span> <span class="nf">doPost</span><span class="p">(</span><span class="nc">HttpServletRequest</span> <span class="n">req</span><span class="p">,</span> <span class="nc">HttpServletResponse</span> <span class="n">resp</span><span class="p">)</span>
        <span class="k">throws</span> <span class="nc">ServletException</span><span class="p">,</span> <span class="nc">IOException</span> <span class="p">{</span>
            <span class="c1">// 주문 로직 호출</span>
            <span class="n">orderService</span><span class="p">.</span><span class="nf">order</span><span class="p">(</span><span class="n">req</span><span class="p">.</span><span class="nf">getParameter</span><span class="p">(</span><span class="s">"item"</span><span class="p">));</span>
        <span class="p">}</span>
    <span class="p">}</span></code>
                </pre>
              </div>
            </div>

            <p class="font-weight-normal">
              위 코드는 Servlet에서 EJB를 호출하는 예시입니다.
              <br />
              <code class="language-plaintext highlighter-rouge">@EJB</code> 어노테이션을 통해 <code class="language-plaintext highlighter-rouge">OrderService</code>를 주입받아 사용합니다.
              <code class="language-plaintext highlighter-rouge">doPost()</code> 메서드에서 주문 요청을 받아 <code class="language-plaintext highlighter-rouge">OrderService</code>의 <code class="language-plaintext highlighter-rouge">order()</code> 메서드를 호출합니다.
              <br />
              <br />
              여기서 EJB는 트랜잭션 관리와 같은 엔터프라이즈 기능을 수행합니다.
              EJB가 트랜잭션을 관리하는 방식을 아래 섹션에서 이어서 알아보겠습니다.
            </p>

            <p class="font-weight-normal">
              <span class="font-weight-bold">2. EJB의 트랜잭션 관리</span><br />
              EJB는 선언적 트랜잭션(ex. <code class="language-plaintext highlighter-rouge">@TransactionAttribute</code>)을 제공해서 Servlet에서 트랜잭션을 관리할 수 있습니다.
              트랜잭션은 데이터베이스 연산을 묶어서 원자성을 보장하고, 데이터 일관성을 유지하는 데 사용됩니다.
              DB 업데이트 중 예외가 발생하면 롤백하거나, 여러 DB 연산을 하나의 트랜잭션으로 묶어서 일관성을 유지할 수 있습니다.

            </p>

            <br />
            <br />

            <h2 id="sub-heading-8" class="font-weight-normal">Servlet 기반 시스템의 성능 최적화</h2>

            <p class="font-weight-normal">
              Servlet 기반 시스템은 성능을 최적화하기 위한 몇 가지 방법이 존재합니다.
              이번 섹션에서는 3가지 주요 방법을 다뤄보도록 하겠습니다.

              <br />
              <br />

              <span class="font-weight-bold">1. 스레드 풀 튜닝</span><br />
              서블릿 컨테이너는 요청마다 스레드를 생성하는 것이 아니라, 미리 생성된 스레드 풀에서 스레드를 할당해 처리합니다.
              스레드 풀의 크기를 적절히 조절하면, 서버의 부하를 줄이고 성능을 향상시킬 수 있습니다.
              <br />
              예를 들어, 다음과 같은 상황이 있을 때 스레드 풀을 튜닝할 수 있습니다.
              <br />
              <br />
              [ 상황 ] 부하 테스트 중 응답 시간이 길어져 톰캣 로그를 확인해보니, 스레드 풀이 꽉 차서 대기 중인 경우
              <br />
              [ 해결 ] <code class="language-plaintext highlighter-rouge">server.xml</code>의 <code class="language-plaintext highlighter-rouge">maxThreads</code> 속성을 늘리거나, <code class="language-plaintext highlighter-rouge">acceptCount</code>를 조절하여 대기 큐를 늘릴 수 있습니다.
              부하 테스트를 통해 스레드 풀의 최적 크기를 찾아주면 더욱 효과적인 성능 튜닝이 될 수 있습니다.
              <br />
              <br />

              <span class="font-weight-bold">2. 비동기 Servlet</span><br />

              Servlet 3.0부터 비동기 서블릿을 지원합니다.
              비동기 서블릿은 요청을 받아 처리하는 동안 다른 작업을 수행할 수 있어, I/O 작업이 많은 서비스에서 성능을 향상시킬 수 있습니다.
              <br />
              예를 들어, 파일 업로드나 외부 API 호출 같은 I/O 작업을 비동기로 처리하면, 서버의 부하를 줄이고 응답 시간을 단축할 수 있습니다.
              다음과 같은 상황이 있을 때 비동기 서블릿을 사용할 수 있습니다.
              <br />
              <br />
              [ 상황 ] 외부 API 호출로 응답이 느려지고, 동기 방식이 병목이 되는 경우<br />
              <span class="font-weight-lighter font-italic" style="font-size: 14px">* 동기 방식 병목: 외부 API 호출이 느려져서 프로그램이 그 응답을 기다리느라 다른 작업을 수행하지 못하는 상태</span><br />
              [ 해결 ] Servlet 3.0의 비동기 처리(<code class="language-plaintext highlighter-rouge">AsyncContext</code>, <code class="language-plaintext highlighter-rouge">startAsync</code>)를 도입해 스레드를 블로킹하지 않고 비동기로 처리하면, 응답 시간을 단축할 수 있습니다.
              <br />
              <br />

              <span class="font-weight-bold">3. 캐싱 도입</span><br />
              캐싱은 반복적인 계산을 줄여 성능을 향상시키는 기법입니다.
              서블릿에서는 메모리 캐시, HTTP 캐시, 데이터베이스 캐시 등 다양한 캐싱 기법을 사용할 수 있습니다.
              <br />
              예를 들어, 다음과 같은 상황이 있을 때 캐싱을 도입할 수 있습니다.
              <br />
              <br />
              [ 상황 ] 반복적인 DB 조회로 부하가 걸려 응답 시간이 느려지는 경우<br />
              [ 해결 ] 자주 조회되는 데이터를 <code class="language-plaintext highlighter-rouge">ServletContext</code>에 캐싱하거나, <code class="language-plaintext highlighter-rouge">@Cacheable</code> 어노테이션을 사용해 메서드 결과를 캐싱하면, DB 조회 횟수를 줄여 성능을 향상시킬 수 있습니다.



            </p>

            <br />
            <br />


            <h2 id="sub-heading-9" class="font-weight-normal">Servlet과 Spring의 연결 고리</h2>

            <p class="font-weight-normal"></p>

            <br />
            <br />

            <h2 id="sub-heading-10" class="font-weight-normal">Servlet 사용 시 주의점</h2>

            <p class="font-weight-normal"></p>

            <br />
            <br />

            <h2 id="sub-heading-11" class="font-weight-normal">마무리</h2>

            <p class="font-weight-normal"></p>

            <br />
            <br />







            <!--              <br />-->
            <!--              Servlet은 싱글톤(Singleton)으로 동작하기 때문에 상태를 잘못 관리하면 문제가 발생할 수 있습니다.-->
            <!--              과거, 전역 변수에 사용자 정보를 저장하는 실수를 한 적이 있는데, 동시에 접속한 사용자들이 서로의 정보를 덮어쓰는 문제가 발생했던 적이 있습니다.-->
            <!--              디버깅하여 로컬 변수로 변경하여 해결했던 기억이 있습니다.-->
            <!--              ThreadLocal을 사용하여 해결하는 것도 하나의 방법이 될 수 있지 않을까 생각합니다.-->
            <!--              따라서, Servlet은 상태를 잘 관리하고, 멀티스레드 환경에서 안전하게 동작할 수 있도록 설계해야 합니다.-->


<!--            <p  class="font-weight-normal">-->
<!--              서론에서도 언급했듯이, CTE는 SQL에서 <code class="language-plaintext highlighter-rouge">WITH</code> 키워드를 사용하여 정의하는 임시 결과의 집합을 의미합니다.-->
<!--              기본 문법은 아래와 같습니다.-->
<!--            </p>-->


<!--            <div class="language-yml highlighter-rouge">-->
<!--              <div class="highlight">-->
<!--                <pre class="highlight">-->
<!--  <code data-lang="sql">-->
<!--    <span class="s">WITH</span> <span class="na">CTE_NAME</span> <span class="pi">AS</span> (-->
<!--      <span class="s">SELECT</span> <span class="na">COLUMN1</span>, <span class="na">COLUMN2</span>-->
<!--      <span class="s">FROM</span> <span class="na">TABLE_NAME</span>-->
<!--      <span class="s">WHERE</span> <span class="na">CONDITION</span>-->
<!--    )-->

<!--    <span class="s">SELECT</span> <span class="o">*</span> <span class="s">FROM</span> <span class="na">CTE_NAME</span>;-->
<!--    </code>-->
<!--</pre>-->
<!--              </div>-->
<!--            </div>-->

<!--            <p class="font-weight-normal"><code-->
<!--              class="language-plaintext highlighter-rouge">WITH</code>를 사용하여 CTE를 정의하고, 이후의 <code-->
<!--              class="language-plaintext highlighter-rouge">SELECT</code>에서 해당 CTE를 하나의 테이블처럼 활용합니다.<br /><br />-->
<!--              위 예시코드를 보시면 알 수 있듯이, CTE를 사용하면 복잡한 서브쿼리를 더 쉽게 이해할 수 있습니다. 또한 동일한 데이터를 여러 번 참조할 수 있어 성능을 개선할 수 있습니다.-->
<!--              PostgreSQL, MySQL 등 일부 DBMS에서는 CTE를 <code-->
<!--                class="language-plaintext highlighter-rouge">MATERIALIZED</code>로 처리하여 중간 결과를 캐싱하여 성능을 높이기도 합니다.-->

<!--              <br />-->
<!--              <br />-->

<!--              MATERIALIZED VIEW는 쿼리의 결과를 저장해두고 필요할 때마다 그 결과를 조회하는 기능을 제공하는 객체입니다. 일반적인 뷰(View)는 쿼리를 저장하지만, 실제 데이터를 저장하지는 않습니다. 반면 MATERIALIZED VIEW는 쿼리의 결과를 저장하여 실제 데이터를 저장합니다. 이를 통해 쿼리의 결과를 미리 계산해두고 필요할 때마다 조회할 수 있어 더 빠르게 결과를 반환할 수 있습니다.-->
<!--            </p>-->

<!--            <br/>-->
<!--            <br/>-->

<!--            <h2 id="sub-heading-2" class="font-weight-normal">CTE를 활용한 계층형 데이터 처리</h2>-->

<!--            <p class="font-weight-normal">-->
<!--              CTE는 계층형 데이터를 처리할 때 유용하게 사용될 수 있습니다. 계층형 데이터는 부모-자식 관계를 가지는 데이터를 의미하며, 대표적인 예시로는 조직도, 카테고리, 트리 등이 있습니다.-->
<!--              CTE를 사용하면 계층형 데이터를 쉽게 조회할 수 있습니다. 아래 예시코드를 통해 CTE를 활용한 계층형 데이터 처리를 살펴보도록 하겠습니다.-->
<!--            </p>-->

<!--            <div class="language-yml highlighter-rouge">-->
<!--              <div class="highlight">-->
<!--                <pre class="highlight">-->
<!--  <code data-lang="sql">-->
<!--    <span class="s">WITH RECURSIVE</span> <span class="na">EmployeeHierarchy</span> <span class="s">AS</span> (-->
<!--      <span class="s">SELECT</span> <span class="na">ID</span>, <span class="na">NAME</span>, <span class="na">MANAGER_ID</span>, <span class="mi">1</span> <span class="s">AS</span> <span class="na">LEVEL</span>-->
<!--      <span class="s">FROM</span> <span class="na">EMPLOYEES</span>-->
<!--      <span class="s">WHERE</span> <span class="na">MANAGER_ID</span> <span class="o">IS</span> <span class="k">NULL</span>  <span class="c">&#45;&#45; 최상위 관리자</span>-->

<!--      <span class="s">UNION ALL</span>-->

<!--      <span class="s">SELECT</span> <span class="na">e.ID</span>, <span class="na">e.NAME</span>, <span class="na">e.MANAGER_ID</span>, <span class="na">h.LEVEL</span> <span class="o">+</span> <span class="mi">1</span>-->
<!--      <span class="s">FROM</span> <span class="na">EMPLOYEES</span> <span class="na">e</span>-->
<!--      <span class="s">JOIN</span> <span class="na">EmployeeHierarchy</span> <span class="na">h</span> <span class="s">ON</span> <span class="na">e.MANAGER_ID</span> <span class="o">=</span> <span class="na">h.ID</span>-->
<!--    )-->

<!--    <span class="s">SELECT</span> <span class="o">*</span> <span class="s">FROM</span> <span class="na">EmployeeHierarchy</span>;-->
<!--    </code>-->
<!--</pre>-->
<!--              </div>-->
<!--            </div>-->

<!--            <p class="font-weight-normal">-->
<!--              위 쿼리는 <code-->
<!--              class="language-plaintext highlighter-rouge">EMPLOYEES</code> 테이블에서 계층형 데이터를 조회하는 재귀 쿼리입니다.-->
<!--              직원들이 어떤 관리자를 가지고 있는지 계층 구조를 따라가며 조직도를 생성하는 방식을 보여줍니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              <code class="language-plaintext highlighter-rouge">WITH RECURSIVE</code> 키워드를 사용하여 CTE를 재귀적으로 정의합니다.-->
<!--              재귀적으로 정의된 CTE는 자기 자신을 참조할 수 있게 됩니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              <code-->
<!--                class="language-plaintext highlighter-rouge">MANAGER_ID IS NULL</code> 조건을 만족하는 직원들은 최상위 관리자를 의미합니다.-->
<!--              이들을 계층의 최상위(root)로 설정하고, <code class="language-plaintext highlighter-rouge">LEVEL</code>을 1로 설정하여 계층 레벨을 부여합니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              이후 <code class="language-plaintext highlighter-rouge">EMPLOYEES</code> 테이블을 <code-->
<!--              class="language-plaintext highlighter-rouge">EmployeeHierarchy</code> CTE와 조인하여 관리자의 ID와 일치하는 직원을 찾습니다.-->
<!--              찾은 직원의 <code class="language-plaintext highlighter-rouge">LEVEL</code>을 상위 관리자의 <code-->
<!--              class="language-plaintext highlighter-rouge">LEVEL</code> + 1 로 설정하여 계층 구조를 표현합니다.-->
<!--              이 과정을 반복하여 모든 직원들의 계층 구조를 조회합니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              이는 아래 테이블과 같이 표현될 수 있습니다.-->
<!--            </p>-->
<!--            <br />-->

<!--            <table>-->
<!--              <thead>-->
<!--              <tr>-->
<!--                <th>ID</th>-->
<!--                <th>NAME</th>-->
<!--                <th>MANAGER_ID</th>-->
<!--                <th>LEVEL</th>-->
<!--              </tr>-->
<!--              </thead>-->
<!--              <tbody>-->
<!--              <tr>-->
<!--                <td>1</td>-->
<!--                <td>CEO</td>-->
<!--                <td>null</td>-->
<!--                <td>1</td>-->
<!--              </tr>-->
<!--              <tr>-->
<!--                <td>2</td>-->
<!--                <td>CTO</td>-->
<!--                <td>1</td>-->
<!--                <td>2</td>-->
<!--              </tr>-->
<!--              <tr>-->
<!--                <td>3</td>-->
<!--                <td>Manager A</td>-->
<!--                <td>2</td>-->
<!--                <td>3</td>-->
<!--              </tr>-->
<!--              <tr>-->
<!--                <td>4</td>-->
<!--                <td>Manager B</td>-->
<!--                <td>2</td>-->
<!--                <td>3</td>-->
<!--              </tr>-->
<!--              <tr>-->
<!--                <td>5</td>-->
<!--                <td>Employee A</td>-->
<!--                <td>3</td>-->
<!--                <td>4</td>-->
<!--              </tr>-->
<!--              <tr>-->
<!--                <td>6</td>-->
<!--                <td>Employee B</td>-->
<!--                <td>3</td>-->
<!--                <td>4</td>-->
<!--              </tr>-->
<!--              <tr>-->
<!--                <td>7</td>-->
<!--                <td>Employee C</td>-->
<!--                <td>4</td>-->
<!--                <td>4</td>-->
<!--              </tr>-->
<!--              </tbody>-->
<!--            </table>-->

<!--            <br />-->

<!--            <p class="font-weight-normal">-->
<!--              이제 <code-->
<!--              class="language-plaintext highlighter-rouge">EmployeeHierarchy</code> CTE에 저장된 데이터를 조회하면, 계층 구조를 반영한 모든 직원들의 정보가 레벨과 함께 출력됩니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              만약 CTE를 사용하지 않고 계층 구조를 조회하려면 셀프 조인(Self Join)을 여러 번 사용해야 하며, 이는 매우 복잡하고 가독성이 떨어지는 쿼리가 될 수 있습니다.-->

<!--              <br />-->
<!--              <br />-->
<!--              CTE를 사용하지 않는 경우의 쿼리는 아래와 같습니다.-->
<!--            </p>-->

<!--            <div class="language-yml highlighter-rouge">-->
<!--              <div class="highlight">-->
<!--                <pre class="highlight">-->
<!--  <code data-lang="sql">-->
<!--    <span class="s">SELECT</span> <span class="na">e1.ID</span>, <span class="na">e1.NAME</span>, <span class="na">e1.MANAGER_ID</span>, <span class="mi">1</span> <span class="s">AS</span> <span class="na">LEVEL</span>-->
<!--    <span class="s">FROM</span> <span class="na">EMPLOYEES</span> <span class="na">e1</span>-->
<!--    <span class="s">WHERE</span> <span class="na">e1.MANAGER_ID</span> <span class="o">IS</span> <span class="k">NULL</span>-->

<!--    <span class="s">UNION ALL</span>-->

<!--    <span class="s">SELECT</span> <span class="na">e2.ID</span>, <span class="na">e2.NAME</span>, <span class="na">e2.MANAGER_ID</span>, <span class="mi">2</span> <span class="s">AS</span> <span class="na">LEVEL</span>-->
<!--    <span class="s">FROM</span> <span class="na">EMPLOYEES</span> <span class="na">e1</span>-->
<!--    <span class="s">JOIN</span> <span class="na">EMPLOYEES</span> <span class="na">e2</span> <span class="s">ON</span> <span class="na">e1.ID</span> <span class="o">=</span> <span class="na">e2.MANAGER_ID</span>-->

<!--    <span class="s">UNION ALL</span>-->

<!--    <span class="s">SELECT</span> <span class="na">e3.ID</span>, <span class="na">e3.NAME</span>, <span class="na">e3.MANAGER_ID</span>, <span class="mi">3</span> <span class="s">AS</span> <span class="na">LEVEL</span>-->
<!--    <span class="s">FROM</span> <span class="na">EMPLOYEES</span> <span class="na">e2</span>-->
<!--    <span class="s">JOIN</span> <span class="na">EMPLOYEES</span> <span class="na">e3</span> <span class="s">ON</span> <span class="na">e2.ID</span> <span class="o">=</span> <span class="na">e3.MANAGER_ID</span>-->

<!--    <span class="s">UNION ALL</span>-->

<!--    <span class="c">&#45;&#45; 계속 반복...</span>-->
<!--    </code>-->
<!--</pre>-->
<!--              </div>-->
<!--            </div>-->

<!--            <p class="font-weight-normal">-->
<!--              이렇게 두 쿼리를 비교해보면 CTE를 사용한 쿼리가 훨씬 간결하고 가독성이 높다는 것을 알 수 있습니다.-->
<!--              또한 트리 깊이가 동적으로 변경될 경우에도 CTE를 사용하면 문제없이 처리가 가능합니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              이처럼 CTE를 활용하면 계층형 데이터를 쉽게 조회할 수 있으며, 복잡한 쿼리를 간결하게 정리할 수 있습니다.-->
<!--            </p>-->

<!--            <br/>-->
<!--            <br/>-->

<!--            <h2 id="sub-heading-3" class="font-weight-normal">윈도우 함수와 CTE</h2>-->

<!--            <p class="font-weight-normal">-->
<!--              CTE는 윈도우 함수와 함께 사용하면 더욱 강력한 기능을 발휘할 수 있습니다.-->
<!--              윈도우 함수는 특정 윈도우(구간)에 대해 집계 함수를 계산하는 함수로, <code-->
<!--              class="language-plaintext highlighter-rouge">RANK</code>, <code-->
<!--              class="language-plaintext highlighter-rouge">DENSE_RANK</code>, <code-->
<!--              class="language-plaintext highlighter-rouge">ROW_NUMBER</code> 등이 있습니다.-->
<!--              CTE를 사용하면 윈도우 함수를 쉽게 적용할 수 있으며, 복잡한 쿼리를 간결하게 정리할 수 있습니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              어떻게 윈도우 함수와 CTE를 함께 사용할 수 있는지 이어서 더욱 자세히 살펴보도록 하겠습니다.-->

<!--              <br />-->
<!--              <br />-->
<!--            </p>-->

<!--            <div class="language-y ml highlighter-rouge">-->
<!--              <div class="highlight">-->
<!--                <pre class="highlight">-->
<!--  <code data-lang="sql">-->
<!--    <span class="s">WITH</span> <span class="na">RankedFishes</span> <span class="s">AS</span> (-->
<!--      <span class="s">SELECT</span> <span class="na">ID</span>, <span class="na">FISH_TYPE</span>, <span class="na">LENGTH</span>,-->
<!--      <span class="s">RANK() OVER</span> <span class="p">(</span><span class="k">PARTITION</span> <span class="k">BY</span> <span class="na">FISH_TYPE</span> <span class="k">ORDER</span> <span class="k">BY</span> <span class="na">LENGTH</span> <span class="k">DESC</span><span class="p">)</span> <span class="k">AS</span> <span class="na">rnk</span>-->
<!--      <span class="s">FROM</span> <span class="na">FISH_INFO</span>-->
<!--    )-->

<!--    <span class="s">SELECT</span> <span class="na">f.ID</span>, <span class="na">fn.FISH_NAME</span>, <span class="na">f.LENGTH</span>-->
<!--    <span class="s">FROM</span> <span class="na">RankedFishes</span> <span class="k">f</span>-->
<!--    <span class="s">JOIN</span> <span class="na">FISH_NAME_INFO</span> <span class="na">fn</span> <span class="s">ON</span> <span class="na">f.FISH_TYPE</span> <span class="o">=</span> <span class="na">fn.FISH_TYPE</span>-->
<!--    <span class="s">WHERE</span> <span class="na">f.rnk</span> <span class="o">=</span> <span class="mi">1</span>-->
<!--    <span class="s">ORDER BY</span> <span class="na">f.ID</span>;-->
<!--    </code>-->
<!--</pre>-->
<!--              </div>-->
<!--            </div>-->

<!--            <p class="font-weight-normal">-->
<!--              위 쿼리는 <code-->
<!--              class="language-plaintext highlighter-rouge">FISH_INFO</code> 테이블에서 어류의 길이를 기준으로 각 어류의 순위를 매기는 쿼리입니다.-->
<!--              <code-->
<!--                class="language-plaintext highlighter-rouge">RANK() OVER (PARTITION BY FISH_TYPE ORDER BY LENGTH DESC)</code>를 사용하여 어류의 종류별로 길이를 기준으로 순위를 매깁니다.-->
<!--              이후 <code-->
<!--              class="language-plaintext highlighter-rouge">FISH_NAME_INFO</code> 테이블과 조인하여 어류의 이름을 조회하고, 각 어류의 길이를 출력합니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              이 경우도 아까와 마찬가지로, CTE를 사용하지 않고 구현한 쿼리와 비교해보며 CTE의 강점을 확인해보도록 하겠습니다.-->
<!--            </p>-->

<!--            <div class="language-yml highlighter-rouge">-->
<!--              <div class="highlight">-->
<!--                <pre class="highlight">-->
<!--  <code data-lang="sql">-->
<!--    <span class="s">SELECT</span> <span class="na">f.ID</span>, <span class="na">fn.FISH_NAME</span>, <span class="na">f.LENGTH</span>-->
<!--    <span class="s">FROM</span> <span class="na">FISH_INFO</span> <span class="k">f</span>-->
<!--    <span class="s">JOIN</span> <span class="na">FISH_NAME_INFO</span> <span class="na">fn</span> <span class="s">ON</span> <span class="na">f.FISH_TYPE</span> <span class="o">=</span> <span class="na">fn.FISH_TYPE</span>-->
<!--    <span class="s">WHERE</span> <span class="p">(</span><span class="na">f.FISH_TYPE</span><span class="p">,</span> <span class="na">f.LENGTH</span><span class="p">)</span> <span class="s">IN</span> <span class="p">(</span>-->
<!--      <span class="s">SELECT</span> <span class="na">f.FISH_TYPE</span>, <span class="s">MAX</span><span class="p">(</span><span class="na">f.LENGTH</span><span class="p">)</span>-->
<!--      <span class="s">FROM</span> <span class="na">FISH_INFO</span> <span class="k">f</span>-->
<!--      <span class="s">GROUP BY</span> <span class="na">f.FISH_TYPE</span>-->
<!--    <span class="p">)</span>-->

<!--    <span class="s">ORDER BY</span> <span class="na">f.ID</span>;-->
<!--    </code>-->
<!--</pre>-->
<!--              </div>-->
<!--            </div>-->

<!--            <p class="font-weight-normal">-->
<!--              위 쿼리는 CTE를 사용하지 않고 구현한 쿼리입니다.-->
<!--              어류의 종류별로 길이를 기준으로 최대값을 구한 뒤, 해당 최대값과 일치하는 어류의 정보를 조회합니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              그러나 CTE를 사용한 쿼리보다 복잡하며, 가독성이 떨어집니다.-->
<!--              또한 CTE를 사용한 쿼리는 어류의 순위를 매기는 로직이 명확하게 드러나기 때문에 이해하기 쉽습니다.-->
<!--              <br />-->
<!--              <br />-->


<!--              이처럼 윈도우 함수와 CTE를 함께 사용하면, 이후 <code-->
<!--              class="language-plaintext highlighter-rouge">JOIN</code>이나 <code-->
<!--              class="language-plaintext highlighter-rouge">WHERE</code> 등의 조건을 더욱 깔끔하게 적용할 수 있습니다.-->

<!--            </p>-->

<!--            <br/>-->
<!--            <br/>-->

<!--            <h2 id="sub-heading-4" class="font-weight-normal">데이터 집계 및 필터링 최적화</h2>-->

<!--            <p class="font-weight-normal">-->
<!--              CTE를 활용하면 중복 연산을 줄일 수 있어, 동일한 데이터 집계를 여러 번 수행할 필요가 없어집니다.-->
<!--              이를 통해 쿼리의 성능을 개선할 수 있습니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              아래에서 더욱 자세히 CTE를 사용하여 데이터 집계 및 필터링을 최적화하는 방법을 살펴보도록 하겠습니다.-->
<!--            </p>-->

<!--            <div class="language-yml highlighter-rouge">-->
<!--              <div class="highlight">-->
<!--                <pre class="highlight">-->
<!--  <code data-lang="sql">-->
<!--    <span class="s">WITH</span> <span class="na">SalesSummary</span> <span class="s">AS</span> (-->
<!--      <span class="s">SELECT</span> <span class="na">PRODUCT_ID</span>, <span class="s">SUM</span><span class="p">(</span><span class="na">SALES</span><span class="p">)</span> <span class="s">AS</span> <span class="na">TOTAL_SALES</span>-->
<!--      <span class="s">FROM</span> <span class="na">SALES</span>-->
<!--      <span class="s">GROUP BY</span> <span class="na">PRODUCT_ID</span>-->
<!--    )-->

<!--    <span class="s">SELECT</span> <span class="na">s.PRODUCT_ID</span>, <span class="na">p.PRODUCT_NAME</span>, <span class="na">s.TOTAL_SALES</span>-->
<!--    <span class="s">FROM</span> <span class="na">SalesSummary</span> <span class="na">s</span>-->
<!--    <span class="s">JOIN</span> <span class="na">PRODUCTS</span> <span class="na">p</span> <span class="s">ON</span> <span class="na">s.PRODUCT_ID</span> <span class="o">=</span> <span class="na">p.PRODUCT_ID</span>;-->
<!--    </code>-->
<!--</pre>-->
<!--              </div>-->
<!--            </div>-->

<!--            <p class="font-weight-normal">-->
<!--              위 쿼리는 <code-->
<!--              class="language-plaintext highlighter-rouge">SALES</code> 테이블에서 제품별 판매량을 집계하는 쿼리입니다.-->
<!--              <code-->
<!--                class="language-plaintext highlighter-rouge">WITH</code>를 사용하여 <code-->
<!--              class="language-plaintext highlighter-rouge">SalesSummary</code> CTE를 정의하고, 이후의 쿼리에서 해당 CTE를 활용하여 제품별 판매량을 조회합니다.-->
<!--              이렇게 CTE를 한번 정의하면, 이후의 쿼리에서는 동일한 데이터 집계를 여러 번 수행할 필요가 없어집니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              만약 CTE를 사용하지 않고 해당 쿼리를 구현한다면 어떻게 될까요?-->
<!--            </p>-->

<!--            <div class="language-yml highlighter-rouge">-->
<!--              <div class="highlight">-->
<!--                <pre class="highlight">-->
<!--  <code data-lang="sql">-->
<!--    <span class="s">SELECT</span> <span class="na">s.PRODUCT_ID</span>, <span class="na">p.PRODUCT_NAME</span>, <span class="s">SUM</span><span class="p">(</span><span class="na">s.SALES</span><span class="p">)</span> <span class="s">AS</span> <span class="na">TOTAL_SALES</span>-->
<!--    <span class="s">FROM</span> <span class="na">SALES</span> <span class="na">s</span>-->
<!--    <span class="s">JOIN</span> <span class="na">PRODUCTS</span> <span class="na">p</span> <span class="s">ON</span> <span class="na">s.PRODUCT_ID</span> <span class="o">=</span> <span class="na">p.PRODUCT_ID</span>-->
<!--    <span class="s">GROUP BY</span> <span class="na">s.PRODUCT_ID</span>;-->
<!--    </code>-->
<!--</pre>-->
<!--              </div>-->
<!--            </div>-->

<!--            <p class="font-weight-normal">-->
<!--              <code-->
<!--                class="language-plaintext highlighter-rouge">SALES</code> 테이블과 <code-->
<!--              class="language-plaintext highlighter-rouge">PRODUCTS</code> 테이블을 조인하여 제품별 판매량을 집계합니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              언뜻 보기에는 CTE를 사용하지 않은 쿼리가 더 간단해 보일 수 있습니다.-->
<!--              그러나 이 경우에는 제품별 판매량을 집계하는 동작이 여러번 필요할 경우 문제가 발생할 수 있습니다.-->
<!--              해당 동작을 필요한만큼 반복해야하기 때문에 중복 연산이 발생할 수 있고, 이는 성능 저하로 이어질 수 있습니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              따라서 CTE를 사용하여 데이터 집계 및 필터링을 최적화하면, 중복 연산을 줄일 수 있어 성능을 개선할 수 있습니다.-->
<!--            </p>-->

<!--            <br />-->
<!--            <br />-->

<!--            <h2 id="sub-heading-5" class="font-weight-normal">주의점</h2>-->

<!--            <p class="font-weight-normal">-->
<!--              CTE를 사용하면 쿼리의 가독성을 높일 수 있으나, 어느 기술이던 그렇듯이 잘못 사용하면 오히려 성능을 저하시킬 수 있습니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              CTE가 <code-->
<!--              class="language-plaintext highlighter-rouge">MATERIALIZED</code>(물리적으로 저장) 되면 성능이 향상될 수 있는것은 사실이나, 일부 DBMS(MySQL)에서는 <code-->
<!--              class="language-plaintext highlighter-rouge">INLINE</code>(그냥 서브쿼리처럼 동작) 처리되어 최적화 효과가 미미할 수도 있습니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              또한 데이터를 여러 번 사용하는 경우가 아니라면 일반 서브쿼리(Subquery)를 사용하는 것이 더 효율적일 수 있습니다.-->
<!--              CTE가 유용한 경우는 동일한 집계 결과를 여러 번 참조해야 할 때이며, 그렇지 않다면 단순한 서브쿼리나 일반 <code-->
<!--              class="language-plaintext highlighter-rouge">JOIN + GROUP BY</code>로 충분히 대체할 수 있습니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              마지막으로, 대용량 데이터에서는 인덱스 활용이 어려울 수 있어, 사용 시 실행 계획(EXPLAIN) 분석이 함께 요구됩니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              따라서 CTE를 사용할 때는 쿼리의 성능과 가독성을 모두 고려하여 적절히 활용해야 합니다.-->
<!--            </p>-->

<!--            <br/>-->
<!--            <br/>-->

<!--            <h2 id="sub-heading-6" class="font-weight-normal">CTE 사용이 필요한 경우</h2>-->

<!--            <p class="font-weight-normal">-->
<!--              CTE를 사용해야 하는 경우는 다음과 같습니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              <span class="font-weight-bold">1. 계층형 데이터 처리:</span>-->
<!--              <br />-->
<!--              &nbsp;&nbsp;&nbsp;&nbsp;계층형 데이터를 쉽게 조회하고 가독성을 높이기 위해 사용합니다. 특히 조직도, 카테고리, 트리 등의 데이터를 처리할 때 유용합니다.-->
<!--              <br />-->
<!--              <span class="font-weight-bold">2. 윈도우 함수와의 조합:</span>-->
<!--              <br />-->
<!--              &nbsp;&nbsp;&nbsp;&nbsp;윈도우 함수를 쉽게 적용하고 가독성을 높이기 위해 사용합니다. 특히 순위를 매기는 경우 유용합니다.-->
<!--              <br />-->
<!--              <span class="font-weight-bold">3. 데이터 집계 및 필터링 최적화:</span>-->
<!--              <br />-->
<!--              &nbsp;&nbsp;&nbsp;&nbsp;중복 연산을 줄이고 성능을 개선하기 위해 사용합니다. 특히 동일한 데이터 집계를 여러 번 수행해야 하는 경우 유용합니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              이외에도 CTE를 사용해야 하는 경우가 있을 수 있으며, 쿼리의 성능과 가독성을 고려하여 적절히 활용해야 합니다.-->
<!--            </p>-->

<!--            <br/>-->
<!--            <br/>-->

<!--            <h2 id="sub-heading-7" class="font-weight-normal">마무리</h2>-->

<!--            <p class="font-weight-normal">-->
<!--              지금까지 CTE의 기본 개념과 활용법에 대해 알아보았습니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              CTE를 활용하면 계층형 데이터 처리, 윈도우 함수와의 조합, 데이터 집계 및 필터링 최적화 등 다양한 기능을 쉽게 구현할 수 있습니다.-->
<!--              하지만 CTE를 사용할 때는 성능을 고려하여 적절히 활용해야 하며, 실행 계획(EXPLAIN) 분석을 통해 사용 여부를 결정해야 합니다.-->
<!--              <br />-->
<!--              <br />-->
<!--              이상으로 CTE 활용법을 마치도록 하겠습니다. 피드백은 언제나 환영입니다. 감사합니다.-->
<!--            </p>-->

            <br/>
            <br/>

          </div>

        </article>

        <div id="giscus_thread" style="max-width: 930px; margin: 0 auto;">
          <script>
            let giscusTheme = determineComputedTheme();
            let giscusAttributes = {
              src: "https://giscus.app/client.js",
              "data-repo": "mjgwon24/mjgwon24.github.io",
              "data-repo-id": "R_kgDON8uq8g ",
              "data-category": "Comments",
              "data-category-id": "DIC_kwDON8uq8s4CnLsu",
              "data-mapping": "title",
              "data-strict": "0",
              "data-reactions-enabled": "1",
              "data-emit-metadata": "0",
              "data-input-position": "bottom",
              "data-theme": giscusTheme,
              "data-lang": "en",
              crossorigin: "anonymous",
              async: "",
            };

            let giscusScript = document.createElement("script");
            try {
              Object.entries(giscusAttributes).forEach(([key, value]) => giscusScript.setAttribute(key, value));
              document.getElementById("giscus_thread").appendChild(giscusScript);
            } catch (error) {
              console.error(error);
            }


          </script>

          <noscript>Please enable JavaScript to view the
            <a href="http://giscus.app/?ref_noscript" rel="external nofollow noopener" target="_blank">comments
              powered by giscus.</a></noscript>
        </div>
      </div>
    </div>
  </div>
</div>
<footer class="fixed-bottom" role="contentinfo">
  <div class="container mt-0"> © Copyright mjgwon24.
  </div>
</footer>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js"
        integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script>
<script src="/assets/js/bootstrap.bundle.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js"
        integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js"
        integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js"
        integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script>
<script defer src="/assets/js/masonry.js?a0db7e5d5c70cc3252b3138b0c91dcaf" type="text/javascript"></script>
<script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js"
        integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script>
<script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script>
<script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script>
<script src="/assets/js/no_defer.js?2781658a0a2b13ed609542042a859126"></script>
<script defer src="/assets/js/common.js?e0514a05c5c95ac1a93a8dfd5249b92e"></script>
<script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script>
<script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script>
<script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script>
<script async src="https://badge.dimensions.ai/badge.js"></script>
<script defer type="text/javascript" id="MathJax-script"
        src="https://cdn.jsdelivr.net/npm/mathjax@3.2.2/es5/tex-mml-chtml.js"
        integrity="sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI=" crossorigin="anonymous"></script>
<script src="/assets/js/mathjax-setup.js?a5bb4e6a542c546dd929b24b8b236dfd"></script>
<script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"
        crossorigin="anonymous"></script>
<script defer src="/assets/js/progress-bar.js?2f30e0e6801ea8f5036fa66e1ab0a71a" type="text/javascript"></script>
<script src="/assets/js/vanilla-back-to-top.min.js?f40d453793ff4f64e238e420181a1d17"></script>
<script>
  addBackToTop();
</script>
<script type="module" src="/assets/js/search/ninja-keys.min.js?a3446f084dcaecc5f75aa1757d087dcf"></script>
<ninja-keys hidebreadcrumbs noautoloadmdicons placeholder="Type to start searching"></ninja-keys>
<script src="/assets/js/search-setup.js?6c304f7b1992d4b60f7a07956e52f04a"></script>
<script src="/assets/js/search-data.js"></script>
<script src="/assets/js/shortcut-key.js?6f508d74becd347268a7f822bca7309d"></script>
</body>
</html>